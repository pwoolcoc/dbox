use std::default::Default;
use serde::ser::{Serialize, Serializer};
use serde;
use serde::de;

#[derive(Debug, PartialEq, Clone)]
pub enum Tag {
    File,
    Folder,
}

impl Serialize for Tag {
    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>
            where S: Serializer
    {
        match *self {
            Tag::File => serializer.visit_unit_variant("Tag", 0, "file"),
            Tag::Folder => serializer.visit_unit_variant("Tag", 1, "folder"),
        }
    }
}

impl serde::de::Deserialize for Tag {
    fn deserialize<D>(deserializer: &mut D) -> Result<Tag, D::Error>
            where D: serde::de::Deserializer
    {
        deserializer.visit(TagVisitor)
    }
}

struct TagVisitor;

impl serde::de::Visitor for TagVisitor {
    type Value = Tag;

    fn visit_string<E>(&mut self, value: String) -> Result<Tag, E>
            where E: serde::de::Error
    {
        match &value[..] {
            "file" => Ok(Tag::File),
            "folder" => Ok(Tag::Folder),
            a => Err(serde::de::Error::syntax(&format!("Unexpected value {}", a))),
        }
    }
}

#[derive(Serialize, Debug, PartialEq, Clone)]
pub struct Metadata {
    #[serde(rename=".tag")]
    tag: String,
    name: String,
    path_lower: String,
    id: String,
    client_modified: String,
    server_modified: String,
    rev: String,
    size: usize,
    sharing_info: Option<SharingInfo>,
}

enum MetadataField {
    Tag,
    Name,
    PathLower,
    ID,
    ClientModified,
    ServerModified,
    Rev,
    Size,
    SharingInfo,
}

impl serde::de::Deserialize for MetadataField {
    fn deserialize<D>(deserializer: &mut D) -> Result<MetadataField, D::Error>
            where D: serde::de::Deserializer
    {
        struct MetadataFieldVisitor;

        impl serde::de::Visitor for MetadataFieldVisitor {
            type Value = MetadataField;
            fn visit_str<E: serde::de::Error>(&mut self, value: &str) -> Result<MetadataField, E> {
                match value {
                    ".tag" => Ok(MetadataField::Tag),
                    "name" => Ok(MetadataField::Name),
                    "path_lower" => Ok(MetadataField::PathLower),
                    "id" => Ok(MetadataField::ID),
                    "client_modified" => Ok(MetadataField::ClientModified),
                    "server_modified" => Ok(MetadataField::ServerModified),
                    "rev" => Ok(MetadataField::Rev),
                    "size" => Ok(MetadataField::Size),
                    "sharing_info" => Ok(MetadataField::SharingInfo),
                    _ => Err(serde::de::Error::syntax("expected field from Metadata struct")),
                }
            }
        }

        deserializer.visit(MetadataFieldVisitor)
    }
}

impl serde::de::Deserialize for Metadata {
    fn deserialize<D>(deserializer: &mut D) -> Result<Metadata, D::Error>
            where D: serde::de::Deserializer
    {
        static FIELDS: &'static [&'static str] = &[".tag", "name", "path_lower", "id", "client_modified", "server_modified", "rev", "size", "sharing_info"];
        deserializer.visit_struct("Metadata", FIELDS, MetadataVisitor)
    }
}

struct MetadataVisitor;

impl serde::de::Visitor for MetadataVisitor {
    type Value = Metadata;

    fn visit_map<V>(&mut self, mut visitor: V) -> Result<Metadata, V::Error>
            where V: serde::de::MapVisitor
    {
        let mut tag_ = None;
        let mut name = None;
        let mut path_lower = None;
        let mut id = None;
        let mut client_modified = None;
        let mut server_modified = None;
        let mut rev = None;
        let mut size = None;
        let mut sharing_info = None;

        loop {
            match try!(visitor.visit_key()) {
                Some(MetadataField::Tag) => { tag_ = Some(try!(visitor.visit_value())); }
                Some(MetadataField::Name) => { name = Some(try!(visitor.visit_value())); }
                Some(MetadataField::PathLower) => { path_lower = Some(try!(visitor.visit_value())); }
                Some(MetadataField::ID) => { id = Some(try!(visitor.visit_value())); }
                Some(MetadataField::ClientModified) => { client_modified = Some(try!(visitor.visit_value())); }
                Some(MetadataField::ServerModified) => { server_modified = Some(try!(visitor.visit_value())); }
                Some(MetadataField::Rev) => { rev = Some(try!(visitor.visit_value())); }
                Some(MetadataField::Size) => { size = Some(try!(visitor.visit_value())); }
                Some(MetadataField::SharingInfo) => { sharing_info = Some(try!(visitor.visit_value())); }
                None => { break; }
            }
        }

        let tag_ = match tag_ {
            Some(tag_) => tag_,
            None => try!(visitor.missing_field("tag_")),
        };
        let name = match name {
            Some(name) => name,
            None => try!(visitor.missing_field("name")),
        };
        let path_lower = match path_lower {
            Some(path_lower) => path_lower,
            None => try!(visitor.missing_field("path_lower")),
        };
        let id = match id {
            Some(id) => id,
            None => try!(visitor.missing_field("id")),
        };
        let client_modified = match client_modified {
            Some(client_modified) => client_modified,
            None => try!(visitor.missing_field("client_modified")),
        };
        let server_modified = match server_modified {
            Some(server_modified) => server_modified,
            None => try!(visitor.missing_field("server_modified")),
        };
        let rev = match rev {
            Some(rev) => rev,
            None => try!(visitor.missing_field("rev")),
        };
        let size = match size {
            Some(size) => size,
            None => try!(visitor.missing_field("size")),
        };
        let sharing_info = match sharing_info {
            Some(sharing_info) => sharing_info,
            None => try!(visitor.missing_field("sharing_info")),
        };

        try!(visitor.end());

        Ok(Metadata {
            tag: tag_,
            name: name,
            path_lower: path_lower,
            id: id,
            client_modified: client_modified,
            server_modified: server_modified,
            rev: rev,
            size: size,
            sharing_info: sharing_info,
        })
    }
}

impl Default for Metadata {
    fn default() -> Metadata {
        Metadata {
tag: "file".to_string(),
            name: "".to_string(),
            path_lower: "".to_string(),
            client_modified: "".to_string(),
            server_modified: "".to_string(),
            rev: "".to_string(),
            size: 0,
            id: "".to_string(),
            sharing_info: Some(SharingInfo {
                read_only: false,
                parent_shared_folder_id: "".to_string()
            }),
        }
    }
}

/// Struct that is returned from the `list_folder` API call
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct FolderList {
    entries: Vec<Metadata>,
    cursor: String,
    has_more: bool,
}

impl Default for FolderList {
    fn default() -> FolderList {
        FolderList {
            entries: vec![],
            cursor: "".to_string(),
            has_more: false,
        }
    }
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct SharingInfo {
    read_only: bool,
    parent_shared_folder_id: String,
}

